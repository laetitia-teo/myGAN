import os
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from models import conv_discr, deconv_gen, fc_discr, fc_gen, deep_gen, deep_discr


class GAN():
    """
    GAN class, contains G (generative) and D (discriminative) networks.
    """    
    def __init__(self, dataset, load_model=False, k=1, m=1):
        
        self.batch_size = 64
        self.dataset = dataset # must support batch iteration
        self.dataset.batch_size = self.batch_size
        # hyperparams
        self.z_dim = 100
        self.k = k # number of discriminative optimization steps
        self.m = m # number of generative optimization steps
        self.training = True
        
        self.zbatch = tf.placeholder(tf.float32, [None, self.z_dim])
        self.images = tf.placeholder(tf.float32, [None, 28, 28, 1])
        
        self.hidden = 100 # do we need them ?
        
        # models
        # images is the generator, it outputs images from the noise vector z.
        # But images is also the entry point for the original images.
        # D is the discriminator
        
        eps = 10e-8
        
        with tf.variable_scope("generator"):
            self.G = self.gen(self.zbatch)
        
        with tf.variable_scope("discriminator") as scope:
            self.D = tf.clip_by_value(self.discr(self.images), eps, 1 - eps)
            scope.reuse_variables() # reusing the discriminator on the generator
            self.Dg = tf.clip_by_value(self.discr(self.G), eps, 1 - eps)
        
        # losses :
        # careful, there's a minus sign
        self.lossD = - tf.reduce_sum(tf.log(self.D))\
                     - tf.reduce_sum(tf.log(1 - self.Dg))
        
        self.lossG = - tf.reduce_sum(tf.log(self.Dg))
        
        # optimizers :
        self.optD = tf.train.AdamOptimizer(0.0001).minimize(self.lossD)
        self.optG = tf.train.AdamOptimizer(0.0001).minimize(self.lossG)
        
        # save path
        self.save_path = os.getcwd() + "/saves/model"
        self.load_model = load_model
        
        # session
    
    def plot_images(self, images):
        """
        Utility function for plotting 8x8 grids of mnist images.
        
        Args : 
            - images (numpy ndarray) : array of 64 mnist images for plotting. 
        """
        for i in range(8):
            for j in range(8):
                if j == 0:
                    row = images[8*i+j]
                else:
                    row = np.concatenate((row, images[8*i+j]), axis=1)
            if i == 0:
                stack = row
            else:
                stack = np.concatenate((stack, row), axis=0)
        plt.imshow(stack, cmap='gray')
        plt.show()
    
    def plot_gen(self):
        """
        Plots a grid of 8x8 images generated by the generator.
        """
        self.training = False
        saver = tf.train.Saver()
        with tf.Session() as sess:
            if not self.load_model:
                print('new session')
                sess.run(tf.global_variables_initializer())
            else:
                try:
                    saver.restore(sess, self.save_path)
                    print('loaded model at %s' % self.save_path)
                except:
                    print('no model was found to load, initializing new session')
                    sess.run(tf.global_variables_initializer())
            zbatch = self.sample_z()
            gen_images = sess.run(self.G, 
                                  feed_dict={self.zbatch: self.sample_z()})
        self.plot_images(gen_images[:, :, :, 0])
        self.training = True
    
    def sample_z(self):
        """
        Function for generation of a random vector of noise in latent space, 
        with a gaussian prior.
        
        Args : 
            - n_samples (int) : number of samples to draw.
        """
        return np.random.normal(size=[self.batch_size, self.z_dim])
        
    def gen(self, z):
        """
        The generative network. Given a vector of noise z, it generates an 
        image according to p_g(z). We want this distribution to be as close as
        possible to the data distribution p_data. 
        """
        return deep_gen(z, self.batch_size)
    
    def discr(self, images):
        """
        The discriminative network. Given a batch of images, it has to 
        discriminate between the ones generated by the generator and the ones
        from the dataset.
        """
        return deep_discr(images, self.training)
    
    def train_D(self, sess, batch, zbatch):
        """
        Training function for the discriminator objective.
        """
        return sess.run((self.optD, self.lossD),
                         feed_dict={self.images: batch,
                                    self.zbatch: zbatch})
    
    def train_G(self, sess, zbatch):
        """
        Training function for the generator objective.
        """      
        return sess.run((self.optG, self.lossG),
                         feed_dict={self.zbatch: zbatch})
                     
    def train(self, n_epochs):
        """
        Outer training loop.
        """
        saver = tf.train.Saver()
        with tf.Session() as sess:
            if self.load_model:
                try:
                    saver.restore(sess, self.save_path)
                    print('loaded model at %s' % self.save_path)
                except:
                    print('no model was found to load, initializing new '
                        + 'session')
                    sess.run(tf.global_variables_initializer())
            else:
                # no model to load, initializing session
                sess.run(tf.global_variables_initializer())
                self.load_model = True
            for epoch in range(n_epochs):
                print('epoch %s' % epoch)
                data_iter = iter(self.dataset)
                while True:
                    # iterate on the dataset, stop when the iterator stops
                    try:
                        for k in range(self.k):
                            # k runs of optimization on the discriminator
                            batch = next(data_iter)
                            zbatch = self.sample_z()
                            _, lossD = self.train_D(sess, batch, zbatch)
                            print('lossD : %s' % lossD)
                        for m in range(self.m):
                            # m runs of optimization on the generator
                            zbatch = self.sample_z()
                            _, lossG = self.train_G(sess, zbatch)
                            print('lossG : %s' % lossG)
                    except(StopIteration):
                        break
                save_path = saver.save(sess, self.save_path)
                print('Model saved in path : %s' % save_path)
                






















    
    
